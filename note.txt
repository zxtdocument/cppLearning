C++ Primer Plus (five version)

数组和指针
char a[3][10];
当计算a[i][j]的时候，编译器会把它变为*(*(a+i)+j)
但是， a并不是一个二级指针，a仍然是一个一级指针， 指向数组的第一个元素。数组在内存中
是按行优先存储的。
char**p=(char**)a;//invalid
char (*p)[10];//声明了一个数组指针。p指向一个char[10]
因此p=a;就是合法的。p+1指针移动10char。指针加减所移动的类型都是以指针的类型为依据。
而char* p[10];则是定义了一个指针数组。含有十个数据， 每个都是一个char*的指针。


Chapter 3
  climits 定义了很多符号常量，如下：
  CHAR_BIT  char bit number
  CHAR_MAX  char max number
  INT_MAX   int max number

  const int MAX=32;
  const 比define好，有明确的类型和c++作用域，同时还能描述复杂结构

  宽字符
  wchar_t a=L'P';
  wout<<L"tall";

  cin.getline()/cin.get() 每次读取一行。getline丢弃换行符;get将换行符保留在输入
  序列里， 下次读取， 第一个将是换行符。

  enum 都是整数。
  enum spectrum {red, oragne, yellow, green, blue, violet, indigo, ultraviolet}
  enum bits{one=1, two=2, three=9};
  default value:0,1,2,3,.....
  {
    spectrum a;
    a=red;//valid
    a=(spectrum)7;//vaild
    a=1;//invalid
    a=red + yellow;//invaild
    a=(spectrum)((int)red + (int)yellow);//vaild
  }


  const char * bird="wren";//const 可以访问wren，但不能更改

  const 作用于指针， 指针指向的内容不可变， 指针本身可变。
  const int* p=&num;
  p=&num2;//valid
  *p=num2;//invalid

  将非const值赋给const是合法的， 反之是非法的。
  cannot convert from "const int*" to "int*"
  const int num1=1;
  int num2=2;
  //int *p=&num1;//invalid
  const int *p=&num1;//valid
  const int *p=&num2;//valid
  num2=9;//valid
  *p=2;//invalid
  赋值是否合法，只有看左右两边的类型即可。(注：const int是可以赋值给int的，因为
  是值传递)
  尽量在值不变的变量前加const语句。

  const变量只能在定义的时候赋值， 期间不能改。

  const成员函数：
  const Stock land=Stock("haha");
  land.show();//error, 因为无法保证show不改变land的内容。
  因此， 要把show声明为const成员函数， 如下：
  void stock::show() const 
  只要方法不改变类的内容， 就应声明为const


Chapter 8 函数
  内联函数：用相应的函数代码替换函数调用。
  在函数声明和定义前面都要加上inline

  引用变量：变量的别名。在声明引用时就要初始化。中途不能赋值。
  int a=1; int & b=a;
  
  函数的列表参数又称为函数的特征标。 

  函数模板(声明和定义前都要加template...)
  template <class T>//或者template <typename T>
  T void(const T & a, const T &b);

  给定函数名， 有非模板函数， 模板函数和显示具体化函数以及它们的重载版本。
  编译器在选择原型时， 非模板版本优于显示具体化和模板函数， 显示具体化函数
  优于模板函数。

  void swap(int &, int&);//非模板函数
 
  template <class T>
  T swap(T &, T &);//模板函数

  template <> swap<job>(job &, job &);//显示具体化函数

  例子：template.cpp


Chapter 9 内存模型和名称空间
  防止文件多次包含：
  #ifndef AA
  #define AA
    //place include file contents here
  #endif

  对于每个非内联的函数， 文件中只能包含一个定义。 所以cpp文件不能多次包含。

  名称空间
  提供一个声明名称的区域。注意，是声明区域名称空间可以是全局的， 也可以位于另一个名称空间中， 但不能位于代码块中。
  除了用户定义的名称空间外， 还有一个默认的全局名称空间。它对应于文件级的声明区域。 全局变量都是位于全局名称空间中。

  使用名称空间的内容：
  Jack::pail=11.1;
  全局名称空间：
  ::fetch

  namespace Jack {
    double fetch;
    struct Hill {};
  }
  char fetch;
  int main(){
    using Jack::fetch; //put fetch into local namespace
    double fetch;//Error!!! Already have a local fetch
    cin>>fetch;//read a value into Jack::fetch
    cin>>::fetch;//read a value into global fetch
  }

Chapter 11 使用类
  算符重载
  class Time{
    private:
        int hours,minutes;
    public:
        Time();
        ~Time();
        Time operator+(Time & t） const;
  };
  重载限制：
  1. 重载后的算符至少有一个是用户自己定义的类型，防止用户为标准类型重载算符。
  2. 操作符与原来的操作句法相同。
  3. 不能定义新的操作符号。例如不能定义operator**()为求幂运算。
  4. 有些操作符不能重载；

  友元简介：
  友元函数/友元类/友元成员函数
  友元函数常常用来重载二元操作符。
  如：
  A=B*3;//convert to A=B.operator*(3);但是没有交换性;
  A=3*B//invalid!
  所以就需要友元函数。友元函数不是类的成员函数， 但可以访问类的私有成员。
  原型如下：
  在类声明中
  friend Time operator*(double m, const Time &t);
  函数定义：（不要再用friend）
  Time operator*(double m, const Time & t)
      Time result;
      ...
      return result;
  }
  操作符左侧对象对应第一个参数， 右侧对象对应第二个参数。
  因此， 要实现以上乘法的交换行，就要定义两个操作函数。

  重载<<算符
  第一种版本：
   cout<<"haha";//cout是一个ostream对象。因此可以通过如下友元函数重载
  void operator<<(ostream &os, coust Time &t){
      os<<t.hours<<":"<<t.mins;
  }
  这就可以使用cout<<t;来输出Time对象。
  但这种版本无法实现：cout<<t1<<t2;这种操作
  第二种版本，同样是友元函数, 可以实现上述操作。
  ostream & operator<<(ostream &os, const Time &t){
    os<<t.hours<<":"<<t.mins;
    return os;
  }

  类的自动转换和强制类型转换
  接受一个参数的类的构造函数， 为将类型与该参数相同的值的转换提供了蓝图。
  只接受一个参数的构造函数才能作为转换函数。
  如有如下构造函数：
  Stonewt (double lbs);
  则：
  Stonewt myCat;
  myCat=19.6;
  程序将使用如上的构造函数生成一个临时对象， 然后采用逐成员赋值的方法，将
  临时对象赋予myCat。 
  
  
  

   


  
